Dec 5th:
--------

Core/Product based - Hyundai, Google, Amazon, PayPal, Apple.
		- High Salary.
		- Shares.
		- Onsite oppurtunities.
		Disadvantage:
		- Firing.

Service based - Companies working for others - Outsourced.
	      - PayPal
		- 7 PP Employees. ( Anually 25L / person)
		- 3 HCL Employees - Service based companies. (Anually 6-7 L /person)
	      - HCL, Infosys, TCS, Wipro.

TATA Motors - Product based.
TATA ELXI - Semiconductor based companies.

IT Companies:

- Developer/Programmer/Tester - C/C++/Java/Python/NodeJS/Scala/HTML/CSS/AKKA.
	- C/C++ - Legacy.
	- Java - Java, Core Java, Advanced Java.
	- PayPal - Frontend application -> Mid Tier application -> Backend Application.



- Customer support - BPO.
- IT Support - Laptop Issue.
- System admin - Java code -> Run.
	Code Java -> JAR/WAR/EXE -> Run -> Server (DC) -> Handles the request.	
		- Server (DC) - 100 HP Servers -> DC 
		- 1 HP SERVER - 10L X 100
		- DC Rent
		- Powersupply and maintenance
		- Server Admin.
		- Man power.
		- Cloud (Private Cloud and Public Cloud)
			- Public (Google Cloud Platform - GCP and Amazon WebServices - AWS)
			- Private Cloud. 
	
- Network admin.
- Database admin.
- DEVOPS admin.
- Storage admin.
- Hadoop admin.
- Batch admin.
- Big Data admin.

BPO - Business process outsourcing.
	- They provide customer support for a product.


IFB:
	- Product of IFB.
	- Desgin engg.
	- HW engg manufacture.
	- Sales engg - sale.
	- Product support - Customer support.

Data Center, Debug ID, 

Java - Frontend application - Login -> It checks your username/password - > Backend (DBA).

Banking application:

Axis 
	- www.axisbank.com -> Frontend
	- Once you login -> Frontend -> Username/password -> backend -> DBA -> Verify and then respond.
	- Username/password is correct
	- Home page -> Account summary, Transfer, Statement, Shopping, Recharge.
		- Account Summary -> Application axis_acc_summ 
		- Statement -> Application axis_statement
		- Transfer -> Application axis_transfer
	
Stateful/Stateless application.

----------------------------------

1. JDK (Java Development Kit) is a Kit that provides the environment to develop and execute(run) the Java program. JDK is a kit(or package) that includes two things

Development Tools(to provide an environment to develop your java programs)

JRE (to execute your java program).
 
2. JRE (Java Runtime Environment) is an installation package that provides an environment to only run(not develop) the java program(or application)onto your machine. 

JRE is only used by those who only want to run Java programs that are end-users of your system.
 
3. JVM (Java Virtual Machine) is a very important part of both JDK and JRE because it is contained or inbuilt in both. 

Whatever Java program you run using JRE or JDK goes into JVM and JVM is responsible for executing the java program line by line, hence it is also known as an interpreter.

Consider a java source file saved as ‘Example.java’. The file is compiled into a set of Byte Code that is stored in a “.class” file. Here it will be “Example.class“. 

JAVA was developed by James Gosling at Sun Microsystems Inc in the year 1991, later acquired by Oracle Corporation.

Java is a class-based, object-oriented programming language and is designed to have as few implementation dependencies as possible. 

A general-purpose programming language made for developers to write once run anywhere that is compiled Java code can run on all platforms that support Java.

Java applications are compiled to byte code that can run on any Java Virtual Machine. The syntax of Java is similar to c/c++.

Primary/Main Features of Java:

Platform Independent: 

Compiler converts source code to bytecode and then the JVM executes the bytecode generated by the compiler. 

This bytecode can run on any platform be it Windows, Linux, macOS which means if we compile a program on Windows, then we can run it on Linux and vice versa.

Each operating system has a different JVM, but the output produced by all the OS is the same after the execution of bytecode. That is why we call java a platform-independent language.

Object-Oriented Programming Language: 

Organizing the program in the terms of collection of objects is a way of object-oriented programming, each of which represents an instance of the class.

The four main concepts of Object-Oriented programming are:

Abstraction
Encapsulation
Inheritance
Polymorphism

Simple: 

Java is one of the simple languages as it does not have complex features like pointers, operator overloading, multiple inheritances, Explicit memory allocation. 

Robust: 

Java language is robust that means reliable. It is developed in such a way that it puts a lot of effort into checking errors as early as possible, that is why the java compiler is able to detect even those errors that are not easy to detect by another programming language. The main features of java that make it robust are garbage collection, Exception Handling, and memory allocation.

Secure:

In java, we don’t have pointers, and so we cannot access out-of-bound arrays i.e it shows ArrayIndexOutOfBound Exception if we try to do so. That’s why several security flaws like stack corruption or buffer overflow is impossible to exploit in Java.      

Write Once Run Anywhere: 

As discussed above java application generates ‘.class’ file which corresponds to our  applications(program) but contains code in binary format. It provides ease t architecture-neutral ease as bytecode is not dependent on any machine architecture. It is the primary reason java is used in the enterprising IT industry globally worldwide.

Name of public class must match the name of .java file in which it is placed (like public class Foo{} must be placed in Foo.java file). So either:

So,

If you file name is study.java then the class name should be "study". Class name should always start with Capital.

Main.java:

public class Main
{
}

Study.java:

public class Study {
    public static void main (String args[]){
        System.out.println("Hi");
    }
}

Java Basic Syntax:
------------------

A Java program is a collection of objects, and these objects communicate through method calls to each other to work together. 

Class: The class is a blueprint(plan) of class objects and status. Class name should be always CAPITAL.

Object: The object is an instance of a class, have Behavior and state.

	Example: A car is an object whose states are: brand, colour, number-plate.
	Behavior: Running on the road.

Method: The behavior of an object is the method.

	Example: The fuel indicator indicates the amount of fuel left in the car.

Instance variables: Every object has its own unique set of instance variables. The state of an object is generally created by the values that are assigned to these instance variables.

Explain about public static void main(String[] args); 
-----------------------------------------------------

public class Main
{
}

What happens when you run a java program without main class ? You will get a Runtime Exception.

Error: Main method not found in class Main, please define the main method as:
   public static void main(String[] args)
or a JavaFX application class must extend javafx.application.Application


** Process exited - Return Code: 1 **

Note the above error comes only during the Run time (java Main) and not during the compile time (javac Main.java)

Why compile does not check ?

Compiler is going to convert the source code to machine code.

Run Time, JVM going to check the Syntax and others.

At Run Time, JVM is responsible to ensure main method exists.

JVM always starts the program execution from the main method.

Main method should be PUBLIC, STATIC, VOID and name of the method (MAIN) and arguments (String args)

Main method:

public static void main(String args[]) -> This is the main method prototype which JVM always looks for.

Why JVM always called main method by the name "main" -> Thats how the JVM is build internally.

Is it possible to change "main" method name from main -> supermain ?
--------------------------------------------------------------------

Yes, it can be changed but JVM customization needed.

Eg: 

public static void supermain(String args[]) ?

public class Main
{
    public static void supermain(String[] args) {
        
    }
}

Output:

Error: Main method not found in class Main, please define the main method as:
   public static void main(String[] args)
or a JavaFX application class must extend javafx.application.Application


** Process exited - Return Code: 1 **

You will end up in the above error. So, the main method should be changed in JVM if you want to change the main method name.

JVM customization required and not advisable.
---------------------------------------------------------------------

Why main method should be always "Public" ?

To call the main method from anywhere in the server (Dir), JVM expects the main method to be public.

Why main method should be "static" ?

Main method is no where related to any Objects. So, to call a main method without any objects - JVM expects "Static"

Why "void" ?

Void will ensure main method does not return any value to JVM. Because JVM cannot do anything with the returned value.

String[] args >

Command line arguements.

So, JVM always expects "public static void main(String[] args)" -> Case sensitive.

Even thought it has to be in the same format. Few changes are accepted for the main method?
---------------------------------------------------------------------------------------------

Order of modifiers can be changed.
	- public static void main(String[] args) can be static public void main(String args[]). No other changes allowed.

Next, String[] args declartion can be interchanged.
	- String[] args
	- String args[]
	- String []args

Next, Instead of "args" any valid identifier can be used.

Next, [] can be also represented by "..." - 3 dots called "varargs" introduced in Java5.

public static void main(String... args)

Varargs were introduced in Java 5 and provide a short-hand for methods that support an arbitrary number of parameters of one type.

Next, We can declare main method with the modifiers "final", "synchronized", "strictfp".

public class Study {
    final static strictfp synchronized public void main(String... b) {
        System.out.println("Hi");
    }
}

---------------------------------------------------------------------------------------------

Can we have 2 main methods ?

Yes. We can. 2 main methods with the same name and diff arguments called "Overloaded Methods".

But, JVM always looks for the main method with (Strings arguments)

public class Study {
    public static void main(String args[]){
        System.out.println("Hi");
    }
    public static void main(String a[]){
        System.out.println("Bye");
    }
}

This will throw error because we are using 2 main method of type string.

Let me change the String -> Int

public class Study {
    public static void main(String args[]){
        System.out.println("Hi");
    }
    public static void main(Integer a[]){
        System.out.println("Bye");
    }
}

This will run and show output as "Hi". Because JVM always look for main method with "String args[]"

Inheritance supported in main method:
-------------------------------------

public class Study {
    public static void main(String args[]){
        System.out.println("Hi");
    }
    class Exam extends Study{
    }
}

So, Parent class "Study" and child class "Exam". If child does not have main method, JVM can look for the main method in Parent class.

---------------------------------------

Method Hiding:
--------------

public class Study {
    public static void main(String args[]){
        System.out.println("Parent Main");
    }
    class Exam extends Study{
        public static void main(String args[]){
            System.out.println("Child Main");
        }
    }
}

We can have dedicated main method for Child class and Parent class called "Method Overriding".

So, for main method inheritance and overloading are allowed. 

But, overriding is not allowed, instead method hiding is applicable.

----------------------------------------------------------------------

Sample Dice program:
====================

Program to generate random number between 1 to 6:

What is purpose of import in Java?

An import statement tells Java which class you mean when you use a short name (like List ). It tells Java where to find the definition of that class. You can import just the classes you need from a package.

random Java Method. 

The Java Math. random() method is used to generate a pseudorandom number, which is a number created with a formula that simulates randomness. 

The Java new keyword is used to create an instance of the class. In other words, it instantiates a class by allocating memory for a new object and returning a reference to that memory. We can also use the new keyword to create the array object.

import java.util.Random;

public class Study{
    public static void main(String args[]){
        Random r = new Random();
        int num = r.nextInt(6) + 1;
        System.out.println("Dice:" + num);

    }
}

------------------------------------------------------------------------------------------------------

Class and Objects:
------------------


Class is a template or blueprint.

Class defines the form of an object.

An object is a specific instance of a class.

Class Vehicle
	- Model
	- Length
	- Seater
	- Top speed
	- Color

Object Hyundai
	- Model i20
	- Length 10ft
	- Seater 5
	- Top Speed 100m/hr
	- Color Black

Object Maruti
	- Model Swift
	- Lenght 8ft
	- Seater 6ft
	- Top Speed 90m/hr
	- Color Blue

So, Class is a central template or blueprint that defines the object.

So, CLASS -> TEMPLATE, OBJECTS -> INSTANCE OF A TEMPLATE.

Class can contain METHOD (FUNCTION).

Instance -> When an object is created and memory allocated for an object.

Member or class Member -> Variables and Methods inside a class are called Member or class member.

Instance variable -> Variable inside a class are called Instance variable.

Defining a Class:
-----------------

Class name{
	Instance variable
	Declare method1,2,etc
}

For every class in a program -> .class file will be generated.

class Study{
    public static void main(String args[]) {
        System.out.println("Study");
    }
}
class Exam{
    public static void main(String... args){
        System.out.println("Exam");
    }
}

class Job{
    public static void main(String args[]){
        System.out.println("Job");
    }
}


The program name is Study.java but its has 3 classes. So, JVM will create 3 class files namely Study.class, Exam.class and Job.class

If I execute$ java Study -> Study main method will be exectued.
$ java Exam -> Exam main method will be executed.
$ java Job -> Job main method will be executed.

When a class is executed, main method inside that class will be executed. If no main method then we get Runtime error.

Will a class file be created if it does not have a main method ?

Yes, compiler will create a class file. But while executing that class file will end up error.

A Java program can have any number of classes but it should have one PUBLIC Class.

// Declaring an integer within the main method and accessing it
public class Class1 {
    public static void main(String args[]){
        int a=5;
        System.out.println(a);
    }

}

O/P: 5

// Declaring an integer within the class and outside main method and accessing it from main method
public class Class1 {
    int a=5;
    public static void main(String args[]){
        System.out.println(a);
    }

}

O/P:java: non-static variable a cannot be referenced from a static context

So, to access class members (Variable/Methods) we need an object.

Lets create an object.

// Declaring an integer within the class and outside main method and accessing it from main method
public class Class1 {
    int a=5;
    public static void main(String args[]){
        Class1 obj = new Class1();
        System.out.println("Value of a:" + obj.a);
    }

}

----------------------------------------------------------------------------------------------------

public class Class1 {
    int a=5;
    public static void main(String args[]){
        int a=10;
        Class1 obj = new Class1();
        System.out.println("Value of a from Class1 " + obj.a);
        System.out.println("Value of a within main method " + a);
    }

}


----------------------------------------------------------------------------------------------------

Java Class and Objects

A class is a blueprint for the object. Before we create an object, we first need to define the class.

An object is any entity that has a state and behavior. 

For example, a bicycle is an object. It has

States: idle, first gear, etc
Behaviors: braking, accelerating, etc.

We can think of the class as a sketch (prototype) of a house. It contains all the details about the floors, doors, windows, etc. Based on these descriptions we build the house. House is the object.

Create a class in Java:
-----------------------

We can create a class in Java using the class keyword. For example,

class ClassName {
  // variables
  // methods
}


A class in Java can contain:

Fields
Methods
Constructors
Blocks
Nested class and interface

public class Student {
    int id=10;
    String name="Rajasekar";
    public static void main(String args[]){
        Student st = new Student();
        System.out.println("Student Name: "+st.name);
        System.out.println("Student ID: "+st.id);

    }
}

Object and Class Example: main outside the class:
------------------------------------------------

If you define multiple classes in a single Java source file, it is a good idea to save the file name with the class name which has main() method.

class TestStudent {
    int id=10;
    String name="Rajasekar";
}

public class Student{
    public static void main(String args[]){
        TestStudent st = new TestStudent();
        System.out.println("Student Name: "+ st.name);
        System.out.println("Student ID: "+ st.id);
    }
}

----------------------------------------------------------

3 Ways to initialize object:
-----------------------------

There are 3 ways to initialize object in Java.

1) By reference variable
2) By method
3) By constructor

class TestStudent {
    int id;
    String name;
}

public class Student{
    public static void main(String args[]){
        TestStudent st = new TestStudent(); // Creating objects
        st.id = 10; // Initialzing objects
        st.name = "Rajaekar";
        System.out.println("Student Name: "+ st.name); // Printing data
        System.out.println("Student ID: "+ st.id);
    }
}

----------------------------------------------------------

We can also create multiple objects and store information in it through reference variable.

class TestStudent {
    int id;
    String name;
}

public class Student{
    public static void main(String args[]){
        TestStudent st = new TestStudent();
        TestStudent st1 = new TestStudent();
        TestStudent st2 = new TestStudent();
        st.id = 10;
        st.name = "Rajaekar";
        st1.id = 20;
        st1.name = "Sarath";
        st2.id = 30;
        st2.name = "Dinesh";
        System.out.println("Student Name: "+ st.name);
        System.out.println("Student ID: "+ st.id);
        System.out.println("Student Name: "+ st1.name);
        System.out.println("Student ID: "+ st1.id);
        System.out.println("Student Name: "+ st2.name);
        System.out.println("Student ID: "+st2.id);

    }
}

----------------------------------------------------------
Object and Class Example: Initialization through method


----------------------------------------------------------

Object and Class Example: Employee

Let's see an example where we are maintaining records of employees.

By default, the classes visibility is package private, i.e. only visible for classes in the same package. The class has no visibility defined like in Java. They are visible if you included them to the compilation unit.

class EmployeeRecord {
    // Declare variables
    int eid;
    String name;
    float salary;
    // Declare methods -1
    void insert(int x,String y,float z){
        eid = x;
        name = y;
        salary = z;
    }
    // Delcare methods -2
    void display(){
        System.out.println("Employee Details: "+ eid + name + salary);
    }
}

class Employee{
    public static void main(String args[]){
        EmployeeRecord e1 = new EmployeeRecord();
        EmployeeRecord e2 = new EmployeeRecord();
        EmployeeRecord e3 = new EmployeeRecord();
        e1.insert(1,"Rajasekar",1000);
        e2.insert(2,"Sarath",2000);
        e3.insert(3,"Dinesh",1500);
        e1.display();
        e2.display();
        e3.display();
    }
}

----------------------------------------------------------

What is the difference between class variables and instance variables in Java?

Instance variables are declared in a class, but outside a method, constructor or any block.

Instance variables are created when an object is created with the use of the keyword 'new' and destroyed when the object is destroyed.

Instance variables can be accessed - ObjectReference.VariableName.

Class variables also known as static variables are declared with the static keyword in a class, but outside a method, constructor or a block.

Static variables are created when the program starts and destroyed when the program stops.

Static variables can be accessed - ClassName.VariableName and ObjectReference.VariableName

class Employee{
    int a=10; //Instance variable
    static int b=20; // Static Variable or Class Variable
    public static void main(String args[]){
        Employee e = new Employee();
        System.out.println(e.a);
        System.out.println(e.b);
        System.out.println(Employee.b);
    }
}


class Employee {
    int a=10;
    public static void main(String args[]){
        System.out.println(a);
    }
}

O/P: java: non-static variable a cannot be referenced from a static context

When you try to access a variable declared outside the main method will create above error. So, to access variable outside the main method we use "STATIC".

class Employee {
    static int a=10;
    public static void main(String args[]){
        System.out.println(a);
    }
}

O/P: 10

class Test{
    int a = 10;
    static int b = 20;
}

class Main{
    public static void main(String args[]){
        Test t = new Test();
        System.out.println(t.a);
        System.out.println(t.b);
       // System.out.println(Test.a);
        System.out.println(Test.b);
    }
}


Static/Clas variables can be accessed via objectname or class name.

But, Instance variable can be accessed via objectname.

Class and Objects quiz:
-----------------------

class Test {
int i;
}
class Main {
public static void main(String args[]) {
	Test t;
	System.out.println(t.i);
}


(A) 0
(B) garbage value
(C) compiler error - java: variable t might not have been initialized
(D) runtime error


Answer: (C)

Explanation: t is just a reference, the object referred by t is not allocated any memory. 

Correct code is:

class Test {
    int i;
}
class Employee {
    public static void main(String args[]) {
        Test t = new Test();
        System.out.println(t.i);
    }
}

What is the output of the program ?

class demo
{
    int a=10;
    int b=20;
    public void print()
    {
        System.out.println ("a = " + a + " b = " + b + "\n");
    }
}

class Employee
{
    public static void main(String[] args)
    {
        demo obj1 = new demo();
        demo obj2 = obj1;
        obj1.a += 1;
        obj1.b += 1;
        System.out.println ("values of obj1 : "+ obj1.a);
        obj1.print();
        System.out.println ("values of obj2 : "+ obj2.b);
        obj2.print();
    }
}

What will be the output of the following program?

public class Rose {
    public Rose(String name) {
        System.out.println("Passed Name is :" + name);
    }
    public static void main(String[] args) {
        Rose myRose = new Rose("red");
        myRose = new Rose("white");
    }
}

Passed Name is :red
Passed Name is :white
Answer is both red and White
Passed Name is :red
Passed Name is :white
Compilation Error or Runtime Error

-----------------------------------------------------------------------------------------------

Java Constructors - Constructors are used to perform Object Initialization.
-----------------

class Student{
    int id;
    String name;
    public static void main(String args[]){
        Student st = new Student();
        System.out.println(st.id);
        System.out.println(st.name);
    }
}

I have a class called Student with 2 variables with no value assigned. 

Default value of Integer and String is 0 and NULL.

Now, Student st = new Student(); Object st has one copy of the class Student.
Student st1 = new Student();
Student st2 = new Student();

So, imagine I am going to create 100 objects for class Student and we will have 100 copies of a class Student with default values given by (JVM) of 0 and NULL. 

Having too many default values is not good.

Its always advised to initialize the object by assiging values to variables once the object is created -> Object Initialization (Assigning values to variables)

So, who does Object Initialization ? Constructors are used to perform Object Initialization.

Name of the class and constructor must be the same.

Syntax of constructor is same must be same as class name. And class variables must be set as arguments for constructors.

NOTE:
----- 

Role of a constructor is not to create an object. Its to initialize an object.

NEW is the keyword for creating an object.


class Student{
    int id;
    String name;
    // Constructor
    Student(int id, String name)
    {
        this.id = id;
        this.name = name;
    }
    public static void main(String args[]){
        Student s1 = new Student(1,"Sarath");
        Student s2 = new Student(2,"Dinesh");
        System.out.println(s1.id+" "+s1.name);
        System.out.println(s2.id+" "+s2.name);
    }
}

If you create 10 object -> 10 times constructor will be executed for initializing the object.

class Student{
    Student()
    {
        System.out.println("I am constructor");
    }
    public static void main(String args[]){
        Student s1 = new Student();
        Student s2 = new Student();
        Student s3 = new Student();
    }
}

When we create an object "Student s1 = new Student();", We use constructor.

So, By default a constructor is created during compiler [NOT JVM] and its invisible. 

Java allows two types of constructors namely
--------------------------------------------

No argument Constructors
Parameterized Constructors

No argument Constructors:
------------------------

class Student{
    int num;
    Student(){
        num = 100;
    }
    public static void main(String args[]){
     Student s = new Student();
     System.out.println(s.num);
    }
}

Parameterized Constructors:
---------------------------

class Student{
    int num;
    String name;
    Student(int i){
        num = i;
        System.out.println(num);
    }
    public static void main(String args[]){
     Student s = new Student(100);
     System.out.println(s.num);
    }
}

---------------------------------------------------------------

class Car{
    int carnum;
    String carname;
    Car(int x, String y){
        carnum = x;
        carname = y;
    }
    public static void main(String args[]){
        Car c1 = new Car(1,"i20");
        Car c2 = new Car(2,"Maruti");
        System.out.println(c1.carnum + "..." + c1.carname);
        System.out.println(c2.carnum + "..." + c2.carname);
    }
}

Rules for constructor:
-----------------------

1) Constructor name should be same as class name.
2) If you add "void" to constructor then it become a METHOD no longer Constructor.

class Student{
    Student(){
        System.out.println("Hi");
    }
    public static void main(String args[]){
        Student s1 = new Student();
        Student s2 = new Student();
    }
}

Above code will print "Hi" twice as we have 2 objects called s1 and s2.

Now, I am going to add void and see what it does.

class Student{
    void Student(){
        System.out.println("Hi");
    }
    public static void main(String args[]){
        Student s1 = new Student();
        Student s2 = new Student();
    }
}

It gives no output as the Constructor becomes Method.

class Student{
    void Student(){
        System.out.println("Hi");
    }
    public static void main(String args[]){
        Student s1 = new Student();
        Student s2 = new Student();
        s1.Student();
        s2.Student();
    }
}

So I have to use objects s1,s2 to access the method.

3) Modifier supported for constructors are public, private, default, protected.

Default constructors:
---------------------

When a class is created and if it does not have a constructor class then compiler [NOT JVM] will create a default (invisible) constructor.

class Student{
}

The above class will have an invisble default constructor created by compiler.

When you create a constructor then, compiler will not create a default constructor.

NOTE: We cannot have default constructor and manual constructor both together.

Default constructors are NO ARGS constructor.

Default constrcutors modifiers are the same as class modifier. If class is public then Default constrcutors is PUBLIC.

STATIC VARIABLES, STATIC METHODS & STATIC BLOCK:
================================================

Static variable: Variable preceding with static is called "static variable" 

static int a;

If you want a variable which should not be object specific then we declare static variable. Like CEO of the company will same for  all the employees. PF office will same for all the employess.

Static variables can be accessed [Outside the class] by # Classname.Staticvariable - No Need of objects. If within the class, We can directly call.

class School{
    int id;
    String name;
    static String schoolname = "St. Joseph";
}

class Student{
    public static void main(String args[]){
        School s1 = new School();
        s1.id=1;
        s1.name="Sarath";
        School s2 = new School();
        s2.id=2;
        s2.name="Dinesh";
        System.out.println(s1.id+" -> "+s1.name+" -> "+ School.schoolname);
        System.out.println(s2.id+" -> "+s2.name+" -> "+ School.schoolname);
    }
}

class School{
    int id;
    String name;
    static String schoolname = "St. Joseph";
    void display(int x, String y){
        id = x;
        name = y;
        System.out.println(id+" -> "+name+" -> "+ schoolname);
    }
}

class Student{
    public static void main(String args[]){
        School s1 = new School();
        s1.id=1;
        s1.name="Sarath";
        School s2 = new School();
        s2.id=2;
        s2.name="Dinesh";
        s1.display(s1.id,s1.name);
        s2.display(s2.id,s2.name);
        
    }
}

-------------------------------------------------------------------------------

Assignments:
------------

How to find entered number is odd or even ?

// Program to find number is odd or even.

public class OddEven {
    public static void main(String args[]){
        int a = 11;
        if ((a%2 == 0)){
            System.out.println(a+" Is Even");}
        else{
            System.out.println(a+" Is Odd");
        }
    }
}

How to get input from a user and print that output ?

// Get user input and print
import java.util.Scanner;
class OddEven{
    public static void main(String args[]){
        Scanner in = new Scanner(System.in);
        System.out.println("Enter A Number: ");
        int num = in.nextInt();
        System.out.println(num);
    }
}


Input Types
In the example above, we used the nextLine() method, which is used to read Strings. To read other types, look at the table below:

Method	Description
nextBoolean()	Reads a boolean value from the user
nextByte()	Reads a byte value from the user
nextDouble()	Reads a double value from the user
nextFloat()	Reads a float value from the user
nextInt()	Reads a int value from the user
nextLine()	Reads a String value from the user  - next()
nextLong()	Reads a long value from the user
nextShort()	Reads a short value from the user


// Get user input and check if its odd or even
import java.util.Scanner;
class Assignment{
    public static void main(String args[]){
        Scanner a = new Scanner(System.in);
        System.out.println("Enter ID, Age and Name");
        int id = a.nextInt();
        int age = a.nextInt();
        String name = a.next();
        System.out.println("ID: "+id);
        System.out.println("Age: "+age);
        System.out.println("Name: "+name);
    }
}

How to get input from user and check if its odd or even ?

The Scanner class is used to get user input, and it is found in the java.util package.

// Get user input and check if its odd or even
import java.util.Scanner;
class OddEven{
    public static void main(String args[]){
        Scanner a = new Scanner(System.in);
        System.out.println("Enter A Number: ");
        int num = a.nextInt();
        if (( num %2 == 0)){
            System.out.println(num+" Is Even");}
        else{
            System.out.println(num+" Is Odd");}
        }
    }

Same code using method.

// Get user input and check if its odd or even via method
import java.util.Scanner;

class OddEvenCheck{
    void oddevencheck(int x){
        if ((x %2 == 0)){
            System.out.println(x+" Is Even");}
        else{
            System.out.println(x+" Is Odd");}
        }
}
class OddEven{
    public static void main(String args[]){
        Scanner a = new Scanner(System.in);
        OddEvenCheck od = new OddEvenCheck();
        System.out.println("Enter A Number: ");
        int num = a.nextInt();
        od.oddevencheck(num);
        }
    }


How to swap two numbers ?

//Swapping 2 numbers
import java.util.Scanner;
public class Assignment {
    public static void main(String args[]){
        int a,b,c;
        Scanner num = new Scanner(System.in);
        System.out.println("Enter 2 numbers: ");
        a = num.nextInt();
        b = num.nextInt();
        System.out.println("Value stored in A and B: "+ a + ".."+ b);
        c = a;
        a = b;
        b = c;
        System.out.println("Value of A and B after swap: "+ a + ".." + b);

    }
}

How to find entered year is leap year or not ?

//How to find leap year.
import java.util.Scanner;
public class Assignment {
    public static void main(String args[]){
        int year;
        Scanner num = new Scanner(System.in);
        System.out.println("Enter a year: ");
        year = num.nextInt();
        if (( year%4 == 0)){
            System.out.println(year+" Is A Leap Year");
        }
        else
        {
            System.out.println(year+" Is Not A Leap Year");
        }


    }
}


How to check a character is vowel or not ?

//How to check a word is vowel or not.
import java.util.Scanner;
public class Assignment {
    public static void main(String args[]){
        char x;
        Scanner letter = new Scanner(System.in);
        System.out.println("Enter a letter: ");
        x = letter.nextLine().charAt(0);
        if (( x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u' || x == 'A'
        || x == 'A' || x == 'E' || x == 'I' || x == 'O' || x == 'U')){
            System.out.println(x +" Is A Vowel");
        }
        else{
            System.out.println(x +" Is Not A Vowel");
        }
    }
}


Write a example for indexof() and lastIndexOf() method.

The indexOf() method returns the position of the first occurrence of specified character(s) in a string.

Use the lastIndexOf method to return the position of the last occurrence of specified character(s) in a string.

//Example for indexof and lastindexof
import java.util.Scanner;
public class Assignment {
    public static void main(String args[]){
        char x;
        Scanner letter = new Scanner(System.in);
        System.out.println("Enter a letter: ");
        x = letter.nextLine().charAt(0);
        String vowel = "aeiouAEIOU";
        if ((vowel.indexOf(x)){
            
        }
    }
}


//Example for indexof and lastindexof
import java.util.Scanner;
public class Assignment {
    public static void main(String args[]){
        char x;
        Scanner letter = new Scanner(System.in);
        System.out.println("Enter a letter: ");
        x = letter.nextLine().charAt(0);
        String vowel = "aeiouAEIOU";
        // If the character exist in vowel string it returns 0 else -1
        if (( vowel.indexOf(x) != -1)){
            System.out.println(x+" Is a vowel");
        }
        else{
            System.out.println(x+" Is not a vowel");
        }
    }
}


Loops in Java:
--------------

For:
----

for (int i = 0; i < 5; i++) {
  System.out.println(i);
}

Java While Loop: The while loop loops through a block of code as long as a specified condition is true
----------------

int i = 0;
while (i < 5) {
  System.out.println(i);
  i++;
}

The Do/While Loop:
------------------

int i = 0;
do {
  System.out.println(i);
  i++;
}
while (i < 5);

The loop will always be executed at least once, even if the condition is false, because the code block is executed before the condition is tested.

Java If ... Else
-----------------

Java supports the usual logical conditions from mathematics:

Less than: a < b
Less than or equal to: a <= b
Greater than: a > b
Greater than or equal to: a >= b
Equal to a == b
Not Equal to: a != b

if (20 > 18) {
  System.out.println("20 is greater than 18");
}

int x = 20;
int y = 18;
if (x > y) {
  System.out.println("x is greater than y");
}

int time = 20;
if (time < 18) {
  System.out.println("Good day.");
} else {
  System.out.println("Good evening.");
}
// Outputs "Good evening."

Java Switch Statements:
------------------------

int day = 4;
switch (day) {
  case 1:
    System.out.println("Monday");
    break;
  case 2:
    System.out.println("Tuesday");
    break;
  case 3:
    System.out.println("Wednesday");
    break;
  case 4:
    System.out.println("Thursday");
    break;
  case 5:
    System.out.println("Friday");
    break;
  case 6:
    System.out.println("Saturday");
    break;
  case 7:
    System.out.println("Sunday");
    break;
}
// Outputs "Thursday" (day 4)

The break Keyword:
------------------

When Java reaches a break keyword, it breaks out of the switch block.

This will stop the execution of more code and case testing inside the block.

int day = 4;
switch (day) {
  case 6:
    System.out.println("Today is Saturday");
    break;
  case 7:
    System.out.println("Today is Sunday");
    break;
  default:
    System.out.println("Looking forward to the Weekend");
}
// Outputs "Looking forward to the Weekend"

Java Break and Continue:
-----------------------

The break statement can also be used to jump out of a loop.

for (int i = 0; i < 10; i++) {
  if (i == 4) {
    break;
  }
  System.out.println(i);
}

Java Continue:
-------------

The continue statement breaks one iteration (in the loop), if a specified condition occurs, and continues with the next iteration in the loop.

for (int i = 0; i < 10; i++) {
  if (i == 4) {
    continue;
  }
  System.out.println(i);
}


----------------------------

Java String replaceAll()
------------------------

public class Main
{
 public static void main(String args[]){
     String data = "Hi How are you ?";
     System.out.println(data);
     data = data.replaceAll("[aeiouAEIOU]", ";");
     System.out.println(data);
 }
}

public class Main
{
 public static void main(String args[]){
     String data = "Hi How are you ?";
     System.out.println(data);
     data = data.replaceAll("Hi", "Bye");
     System.out.println(data);
 }
}

--------------------------------------


import java.util.Locale;
import java.util.Scanner;
public class Assignment {
    public static void main(String args[]){
        Scanner data = new Scanner(System.in); // Creating an object for the scanner class
        System.out.println("Enter 3 Strings: ");
        String str1 = data.next();
        String str2 = data.next();
        String str3 = data.next();
        System.out.println("String1: "+str1);
        str1 = str1.replaceAll("[aeiouAEIOU]","\"");
        System.out.println("String1 replaced: "+str1);
        System.out.println("String2: "+str2);
        str2 = str2.replaceAll("[BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz]","*");
        System.out.println("String2 replaced: "+str2);
        System.out.println("String3: "+str3);
        str3 = str3.toLowerCase();
        System.out.println("String3 lowecase: "+str3);

    }
}


-------------------------------------------

Method Overriding and overloading:
----------------------------------

- Constructor overloading.
- Method overloading.
- Operator overloading. (+) symbol used for addition and concentattion.

Overloading: Same method name with different arguements. - POLYMORPHISM. One function acting in many forms.

add();
add(int a,int b);

This feature is not available in C.

//Constructor overloading

class Test{
    Test(){
        System.out.println("Constructor with no arguement");
    }
    Test(int i){
        System.out.println(i + " - Constructor with arguement");
    }
}
public class Main
{
    public static void main(String[] args) {
        Test a = new Test();
        Test a1 = new Test(10);
    }
}

Method Overloading:
-------------------

//Method overloading

class Test{
    void add(){
        int a, b;
        a = 10;
        b = 20;
        int c = a+b;
        System.out.println("A+B: "+c);
    }
    void add(int a, int b){
        int c = a + b;
        System.out.println("A+B: "+c);
    }
}
public class Main
{
    public static void main(String[] args) {
        Test a = new Test();
        a.add();
        a.add(100,200);
    }
}


METHOD OVERRIDING: [INHERITANCE]
-----------------

Inheritance:

class Animal {
  // methods and fields
}

// use of extends keyword
// to perform inheritance

class Dog extends Animal {

  // methods and fields of Animal
  // methods and fields of Dog
}

//Inheritance

class Doctor{
    void Doctor_Details(){
        System.out.println("Doctor Details");
    }
}

class Surgeon extends Doctor{
    void Surgeon_Details(){
        System.out.println("Surgeon Details");
    }
}
public class Assignment
{
    public static void main(String[] args) {
        Surgeon sur = new Surgeon();
        sur.Doctor_Details();
        sur.Surgeon_Details();
    }
}


So, What is overriding ?

When the same method name used in Parent and Child class. And child class not happy with Parent class method, then it can use Child class method.

So, child class method [OVERRIDING METHOD] is OVERRIDING parent class method [OVERRIDEN METHOD].

//Inheritance

class Doctor{
    void Doctor_Details(){//OVERIDDEN METHOD
        System.out.println("Doctor Details From Apollo");
    }
}

class Surgeon extends Doctor{
    void Doctor_Details(){ //OVERRIDING METHOD
        System.out.println("Surgeon Details From KMC");
    }
}
public class Assignment
{
    public static void main(String[] args) {
        Doctor dor = new Doctor();
        dor.Doctor_Details();
        Surgeon sur = new Surgeon();
        sur.Doctor_Details();
    }
}

Now, How do I override the parent method class?

//Inheritance

class Doctor{
    void Doctor_Details(){
        System.out.println("Doctor Details From Apollo");
    }
}

class Surgeon extends Doctor{
    void Doctor_Details(){
        System.out.println("Surgeon Details From KMC");
    }
}
public class Assignment
{
    public static void main(String[] args) {
        Doctor x = new Surgeon(); // PAREANT CLASS OBJECT CREATE WITH CHILD CLASS CONSTRCTUOR.
        x.Doctor_Details();
    }
}


So,this overriding will be happening during RUN TIME (JVM) not at the COMPILE TIME.

overriding also called "Dynamic Polymorphism", "Run time Polymorphism", "Late Binding".

Method Overriding Rules Part - 1
--------------------------------

1) Method name must be same and arguement must be the same.

2) Method return type must be same until Java 1.4 but from Java 1.5 co-variant method return (return type can be anything) is accepted.

3) Private methods are not applicable in Overriding as they are available within the class.

But, If you have private method in Parent class and another private method in Child class - Its not OVER RIDING.

4) If parent class method is declared "FINAL" - Overriding not acceptable.

Same, If final method declared in both Parent and Child then Overriding not acceptable.

----------------------------------------

Java Access Modifiers - Learn Public, Private, Protected and Default

Summary:
1. private: accessible in the same file
2. default: accessible  in the same package 
3. protected: accessible  in the same package; accessible in all packages w/ "extend" E.g. otherpackage extend package1{
4. public: accessible  in all packages

Class Level Modifiers public and default:
----------------------------------------

When we create a class, We need to inform about our class to JVM. What to inform ?

Whether is can be accessible outside or not.

So, We use modifiers - Modifiers describe the behaviour of the class.

If the class is Public, Then its accessible from anywhere.

Eg: 

public class Test{
}

What is the default modifier for a class ? Its default.

class Test{
}

Which means the class is accessible within the package.

Next, How to mention if object creation is allowed for a class or not ?

If the class is mentioned "Abstract" then object creation is not possible.

Eg:

abstract class Test{
}

Next, If "final" keyword is used, then Child class creation is not possible.

Eg:

final class Test{
}


What are the modifiers allowed in top level class ?

public, default, abstract, final 

class Test{
{

What are the modifiers allowed in inner class?

private, protected, static

class Test{
	class School{ //private, protected, static
	}
}

Eg:

Create a package pack1:


package pack1;

public class Program1 {
    public int num = 100;
}

Create another package called pack2:

package pack2;
import pack1.Program1;

public class Program2 {
    public static void main(String args[]){
        Program1 a = new Program1();
        System.out.println(a.num);
    }
}

public int num = 100; -> So that the integers accessible from outside the class and from any packages.

If the class is "DEFAULT" then its accessible within the package.

You will get compile time error: java: pack1.Program1 is not public in pack1; cannot be accessed from outside package

package pack1;

class Program1 { // Default class.
    public int num = 100;
}

Java Abstract Modifier 
----------------------

We have abstract method and abstract class - NO ABSTRACT VARIABLES.

Abstract method just has declaration not any definition/implemntation {}. The who provide implementation ? Child class to provide implementation.

Abstract method ends with ";"

Eg:

public class Vehicle{
	public abstract int getnofwheels();
}

public class Fruits{
	public abstract String getTaste();
}

Abstract method should always end with ";" not {}

Eg

class Assignment{
    public abstract void Class();
}

Above may look correct interms for abstract method declartion. But it will throw error. So, solution is "If a class contains atleast one abstract method then the class must be ABSTRACT"

abstract class Assignment{
    public abstract void Class();
}


Abstract Class:
---------------

Partially implemented class is called Abstract class. We cannot create objects for abstract class.

Eg:

abstract class Test{

}

abstract class Assignment{
    public static void main(String args[]){
        Assignment a = new Assignment();
    }
}

Error: java: Assignment is abstract; cannot be instantiated

Java quiz 1:
------------

public class Student
{
  String name = "Emily";
  int age = 20;
   
  Student(String name, int age)
  {
    this.name = name;
    this.age = 22;
  }
  public static void main(String[] args)
  {
    Student st = new Student("Oliver", 21);
    System.out.print(st.name);
    System.out.print(", " + st.age);
  }
}


What is written to the standard output as the result of executing the following code?

public class MyClass
{
  public static void main(String[] args)
  {
    int a = 8;
    int b = 12;
    boolean bool = false;
 
    if (a < b)
    {
      System.out.print("X");
    }
    if (!bool == false)
    {
      System.out.print("W");
    }
    if (a + b == 21)
    {
      System.out.print("Y");
    }
    else
    {
      System.out.print("Z");
    }
  }
}


Java quiz 3: The difference between static and instance variables

public class MyClass
{
  int x;
  static int y;
 
  MyClass(int i)
  {
    x += i;
    y += i;
  }
  public static void main(String[] args)
  {
    new MyClass(2);
    MyClass mc = new MyClass(3);
    System.out.print(mc.x + "," + mc.y);
  }
}

The statement y += i; increments the value of y by 3. The variable y is a static (class) variable and its last
value was 2. Therefore the value of y becomes 2 + 3 = 5 and that value is the same for all the objects of the class.The correct answer is c. 3, 5.


Java quiz 4: Overriding methods

What is written to the standard output as the result of executing the following code?

public class MyClass
{
  public static void main(String[] args)
  {
    int a = 4;
    int b = 6;
    if (a < b)
    {
      System.out.print("x");
    }
    else if (b > 5)
    {
      System.out.print("y");
    }
    else
    {
      System.out.print("z");
    }
  }
}

What is written to the standard output as the result of executing the following code?


public class WhileLoop
{
  public static void main(String[] args)
  {
    int i = 1;
    while (i < 9)
    {
      i += 2;
      System.out.print(i);
    }
  }
}


What is written to the standard output as the result of executing the following code?

public class Condition
{
  public static void main(String[] args)
  {
    int x = 2;
    String str = "";
    boolean isActive = false;
    if(!isActive)
    {
      str += x;
      x += 3;
      System.out.print(str);
      isActive = true;
    }
    if(isActive)
    {
      str += x;
      System.out.print(str);
    }
  }
}

What is written to the standard output as the result of executing the following code?

public class MyClass
{
  public static void main(String[] args)
  {
    int i = 1;
    int x = 1;
    while(i < 4)
    {
      x += i;
      i++;
    }
    System.out.print(x);
  }
}


What happens when the following program is compiled and run?

public class Car
{
  public static void main(String[] args)
  {
    String str1 = "Java";
    String str2 = "Java";
    String str3 = "java";
    if(str1 == str2)
    {
      System.out.print("w");
    }
    if(str1.equals(str2))
    {
      System.out.print("x");
    }
    if(str2.equals(str3))
    {
      System.out.print("y");
    }
    else
    {
      System.out.print("z");
    }
  }
}


What is the output of this code?

public class MyLoop
{
  public static void main(String[] args)
  {
    int y = 0;
    while(y < 14)
    {
      y++;
      for(int i = 1; i < 4; i++)
      {
        y += i;
      }
    }
    System.out.println(y);
  }
}


What is the output of this code?

public class MyClass
{
  public static void main(String[] args)
  {
    int x = 3;
    int y = (x < 3) ? 4 : 8;
    System.out.print(y);
  }
}

What is the output of the following code?

public class Car
{
  Car()
  {
    System.out.print("Toyota");
  }
   
  static String brand1 = getBrand("BMW ");
  String brand2 = getBrand("Volvo ");
  static
  {
    System.out.print("Porshe ");
  }
   
  public static String getBrand(String brand)
  {
    System.out.print(brand);
    return brand;
  }
  public static void main(String[] args)
  {
    Car car = new Car();
  }
}

--------------------------------------------------------------------------

Pre Increment Operator:

If an Increment operator is used in front of an operand, then it is called  as Pre Increment operator.

Syntax:

++x : which increments the value by 1 of ‘x’ variable.

class Assignment {

    public static void main(String[] args) {
        int x = 10;
        int y = ++x;
        System.out.println("y value is: " + y);
    }

}

y value is: 11
x value is: 11

As per example, the initial value of ‘x’ is 10. After applying pre-increment operator on ‘x’ the value of ‘x’ is incremented by 1 (i.e., 11) and that value is assigned to the variable ‘y’. So that the final value of  ‘y’ is 11.

class Assignment {

    public static void main(String[] args) {
        int x = 10;
        int y = x++;
        System.out.println("x value is: " + x);
        System.out.println("y value is: " + y);
    }

}

As per example, the initial value of ‘x’ is 10. After applying post-increment operator the current values of ‘x’ (i.e, 10) is assigned to y, and then the value of ‘x’ is incremented by 1. So when displaying variable ‘y’ it is showing as 10.

class Assignment {

    public static void main(String[] args) {
        int x = 10;
        int y = ++x;
        System.out.println("x value is: " + x);
        System.out.println("y value is: " + y);
    }

}

Pre increment operator is applied  on x operand, here first the value of x will be incremented by 1 and then the incremented value will be assigned to the variable y .

As per example, the initial value of ‘x’ is 10. After applying pre-increment operator on ‘x’ the value of ‘x’ is incremented by 1 (i.e., 11) and that value is assigned to the variable ‘y’. So that the final value of  ‘y’ is 11.

Post Increment:

class Assignment {

    public static void main(String[] args) {
        int x = 10;
        int y = x++;
        System.out.println("x value is: " + x);
        System.out.println("y value is: " + y);
    }

}

In post increment. Value of x is assigned to y and x will be incremented.

-------------------------------------------------------------------------

Java Package Statement
----------------------

A package in Java is used to group related classes. Think of it as a folder in a file directory.

We use packages to avoid name conflicts, and to write a better maintainable code. Packages are divided into two categories:

Built-in Packages (packages from the Java API)
User-defined Packages (create your own packages)

Package = Java classes and Interfaces.

Advantage of packages:

1) Avoid naming conflict. Eg: date class is avaiable in SQL package and UTIL package.

2) Modularity and Maintainability of application. Eg: IO operations are available under java.io.* and SQL operations are available under java.sql.*

import package.name.Class;   // Import a single class
import package.name.*;   // Import the whole package

import java.util.Scanner;

java.util is a package, while Scanner is a class of the java.util package.

NOTE:

In any JAVA program, Only one package statement is allowed.

package Test;

public class Test {
    public static void main(String args[]){
        System.out.println("Hi");
    }
}

The below will throw an error:

package Test;
package Test1;
public class Test {
    public static void main(String args[]){
        System.out.println("Hi");
    }
}

How to import packages ?

package P1;

public class School {
    public static void main(String args[]){
        System.out.println("Hi. I am from P1 Package");
}
}

Creating another package P2:

package P2;
import P1.School;
public class Class {
    public static void main(String args[]){
        School obj = new School();
    }
}


Eg:

package P1;
public class School{
    public int a = 100;
    public String name = "Welcome";
}


package P2;
import P1.School;
public class Class {
    public static void main(String args[]){
        School obj = new School();
        System.out.println(obj.a);
        System.out.println(obj.name);

    }
}

--------------------------------------------------

Java Access Modifiers

In Java, access modifiers are used to set the accessibility (visibility) of classes, interfaces, variables, methods, constructors, data members, and the setter methods. For example,

class Animal {
    public void method1() {...}

   private void method2() {...}
}

method1 is public - This means it can be accessed by other classes.

method2 is private - This means it can not be accessed by other classes.

Note the keyword public and private. These are access modifiers in Java. They are also known as visibility modifiers.

Default -	declarations are visible only within the package (package private)
Private	- declarations are visible within the class only
Protected -	declarations are visible within the package or all subclasses
Public -	declarations are visible everywhere


Default Access Modifier:
------------------------

If we do not explicitly specify any access modifier for classes, methods, variables, etc, then by default the default access modifier is considered. For example,

package defaultPackage;
class Logger {
    void message(){
        System.out.println("This is a message");
    }
}

Here, the Logger class has the default access modifier. And the class is visible to all the classes that belong to the defaultPackage package.

However, if we try to use the Logger class in another class outside of defaultPackage, we will get a compilation error.

Private Access Modifier:
------------------------

When variables and methods are declared private, they cannot be accessed outside of the class. For example,

The below code works:

class Student{
    String name = "Sarath";
}

class Main
{
    public static void main(String[] args) {
        Student obj = new Student();
        System.out.println(obj.name);
    }
}


When I make the class "Private" or the variable "Private" it will not work.

private class Student{
    String name = "Sarath";
}

class Main
{
    public static void main(String[] args) {
        Student obj = new Student();
        System.out.println(obj.name);
    }
}

Eg:
---

If your class has mixed of private and public will fail too.

class Student{
    private String name = "Sarath";
    int a = 10;
}

class Main
{
    public static void main(String[] args) {
        Student obj = new Student();
        System.out.println(obj.name + obj.a);
    }
}

Protected Access Modifier:
--------------------------

When methods and data members are declared protected, we can access them within the same package as well as from subclasses. 

class Animal {
    // protected method
    protected void display() {
        System.out.println("I am an animal");
    }
}

class Dog extends Animal {
    public static void main(String[] args) {

        // create an object of Dog class
        Dog dog = new Dog();
         // access protected method
        dog.display();
    }
}

Public Access Modifier:
-----------------------

When methods, variables, classes, and so on are declared public, then we can access them from anywhere. The public access modifier has no scope restriction. 

// Animal.java file
// public class
public class Animal {
    // public variable
    public int legCount;

    // public method
    public void display() {
        System.out.println("I am an animal.");
        System.out.println("I have " + legCount + " legs.");
    }
}

// Main.java
public class Main {
    public static void main( String[] args ) {
        // accessing the public class
        Animal animal = new Animal();

        // accessing the public variable
        animal.legCount = 4;
        // accessing the public method
        animal.display();
    }
}

Here,

The public class Animal is accessed from the Main class.
The public variable legCount is accessed from the Main class.
The public method display() is accessed from the Main class.


Getter and Setter in Java:
--------------------------

Getter and Setter are methods used to protect your data and make your code more secure.

class Bank{
    int minbalance = 100;
}

class Accholder{
    public static void main(String args[]){
        Bank bk = new Bank();
        System.out.println("Minimum Bal: "+ bk.minbalance);
        // Overwrite the minimum minbalance
        bk.minbalance = 200;
        System.out.println("Minimum Bal: "+ bk.minbalance);
        
    }    
}

Here we are overwriting the minmum balance from main method.

What if I change the minbalance as "PRIVATE" ?

class Bank{
    private int minbalance = 100;
}

class Accholder{
    public static void main(String args[]){
        Bank bk = new Bank();
        System.out.println("Minimum Bal: "+ bk.minbalance);
        // Overwrite the minimum minbalance
        bk.minbalance = 200;
        System.out.println("Minimum Bal: "+ bk.minbalance);
        
    }    
}

Will result: NOTE: We cannot even view the private variable outside the class.

Accholder.java:8: error: minbalance has private access in Bank
        System.out.println("Minimum Bal: "+ bk.minbalance);
                                              ^
Accholder.java:10: error: minbalance has private access in Bank
        bk.minbalance = 200;
          ^
Accholder.java:11: error: minbalance has private access in Bank
        System.out.println("Minimum Bal: "+ bk.minbalance);
                                              ^
3 errors


** Process exited - Return Code: 1 **

So, how to view a private variable outside the class ? without modifying it.

class Bank{
    private int minbalance = 100;
    public int minBal(){
        return this.minbalance;
    }
}

class Accholder{
    public static void main(String args[]){
        Bank bk = new Bank();
        int min_bal = bk.minBal();
        System.out.println("Minimum Bal: "+ min_bal);
        
    }    
}

We create a method called minBal which will return minbalance. So, this cannot be overriden.


Java Arrays:
------------

Array is collection of objects of same type and fixed length.

String [] - Collection of string.
Integer [] - Collection of integers.

Array objects are added/removed based on Index.

Index starts from 0 and ends with N-1.

Array format:

1) Declaration of array: int[] a;

2) Instantation of array object: a = new int[5];

3) Assigning values: a[0]=10;

Advantages:

Code Optimization: It makes the code optimized, we can retrieve or sort the data efficiently.
Random access: We can get any data located at an index position.

Disadvantages:

Size Limit: We can store only the fixed size of elements in the array. It doesn't grow its size at runtime. To solve this problem, collection framework is used in Java which grows automatically.


// declare an array
double[] data;

// allocate memory
data = new double[10];

//declare and initialize and array
int[] age = {12, 4, 5, 2, 5};

// declare an array
int[] age = new int[5];

// initialize array
age[0] = 12;
age[1] = 4;
age[2] = 5

// access array elements
array[index]

Above 3 steps can also be performed in a single step:

int[] a = {1,2,3,4,5};

public class Main
{
    public static void main(String[] args) {
        int a[] = {1,2,3,4,5};
        System.out.println(a[0]);
        System.out.println(a[1]);
        System.out.println("Length of array: " + a.length);
        for(int i=0;i<a.length;i++){
            System.out.println("Value on index" + i +"->"+a[i]);
        }
    }
}

Default value stored in an array is 0.


public class Main
{
    public static void main(String[] args) {
        int a[] = new int[5];
        System.out.println(a[0]);
        System.out.println(a[1]);
    }
}

--------------------------------------------

public class Main
{
    public static void main(String[] args) {
        int a[] = new int[5];
        a[1] = 10;
        a[2] = 20;
        System.out.println(a[0]);
        System.out.println(a[1]);
        }
}

--------------------------------------------
public class Main
{
    public static void main(String[] args) {
        int a[] = {1,2,3,4,5};
        for (int i=0; i< a.length; i++){
            System.out.println(a[i]);
        }
    }
}

--------------------------------------------

Finding length of the array:

public class Main
{
    public static void main(String[] args) {
       int[] numbers = {2, -9, 0, 5, 12, -25, 22, 9, 8, 12};
       // Length of the array.
       System.out.println(numbers.length);
    }
}

--------------------------------------------

Java Copy Arrays: Copying Arrays Using Assignment Operator

	public class Main
{
    public static void main(String[] args) {
       int[] a = {1,2,3,4,5};
       int b[] = a;
       for (int i=0; i < b.length; i++){
           System.out.println(a[i]+"->"+b[i]);
       }
    }
}

--------------------------------------------
Using Looping Construct to Copy Arrays:

public class Main
{
    public static void main(String[] args) {
       int[] a = {1,2,3,4,5};
       int b[] = new int[a.length];
       for(int i=0; i < a.length; i++){
            b[i] = a[i];
            System.out.println("Value of A and B:"+ a[i]+"->"+b[i]);
       }
       
    }
}

-------------------------------------------- 

Sort an Array using Method:

import java.util.Arrays;

public class Main
{
    public static void main(String[] args) {
       int num[] = {90, 23, 5, 109, 12, 22, 67, 34};
       Arrays.sort(num);
       for (int i=0; i< num.length; i++){
           System.out.println(num[i]);		
       }
    }
}


--------------------------------------------

//Compute Sum and Average of Array Elements

class Main{
    public static void main(String args[]){
        int a[] = {1,2,3,4,5,6,7,8,9};
        //System.out.println(a.length);
        int sum = 0;
        float avg = 0;
        for(int i=0;i<a.length;i++){
            sum = sum + a[i];
        }
        System.out.println("Sum of array: "+ sum);
        avg = sum/a.length;
        System.out.println("Average of array: "+ avg);
    }
}

//Compare 2 Arrays 

class Main{
    public static void main(String args[]){
        int a[] = {1,2,3};
        int b[] = {1,2,3};
        if (a == b){
            System.out.println("Same");
        }else{
            System.out.println("Not Same");
        }
    }
}

Above will not work.

We need to compare both the array values. Make sure the length of both the arrays are same.

We can use Arrays class from java.util.

//Compare 2 Arrays
import java.util.Arrays;

class Main{
    public static void main(String args[]){
        int a[] = {1,2,3};
        int b[] = {1,1,3};
        if (Arrays.equals(a, b)){
            System.out.println("Same");
        }else{
            System.out.println("Not Same.");
        }
    }
}

//Compare 2 Arrays without using inbuild class

class Main{
    public static void main(String args[]){
        int a[] = {8,2,3};
        int b[] = {1,9,3};
        int count = 0;
        if (a.length == b.length){
            for (int i=0; i < a.length; i++){
                if (a[i] != b[i]){
                    System.out.println("Not Same");
                    break;
                }else
                {
                    count = count + 1;
                    if (count == a.length){
                        System.out.println("Same");
                    }
                }
            }
        }
    }
}

Add elements to Array in Java:
------------------------------

An array is the collection of similar types of elements stored at contiguous locations in the memory.

In Java Arrays are mutable data types, i.e., the size of the array is fixed, and we cannot directly add a new element in Array. However, there are various ways to add elements to the array.

We can use the following methods to add elements to arr.

By creating a larger size array than arr.
By using ArrayList
By shifting the element to adjust the size of arr.

//Compare 2 Arrays without using inbuild class
import java.util.*;

class Main{
    public static void main(String args[]){
        int a[] = {8,2,3}; // 0-1-2
        int b[] = new int[a.length + 1];
        System.out.println("A length: "+ a.length);
        System.out.println("B length: "+ b.length);
        Scanner s = new Scanner(System.in);
        System.out.println("Enter An Integer: ");
        int temp = s.nextInt();
        for(int i=0; i < a.length; i++){
            b[i] = a[i];
        }
        b[a.length] = temp;
        for(int i=0; i < b.length; i++){
            System.out.println(b[i]);
        }
}
}

// Check an element in an array

// Check an element in an array 
import java.util.*;
class Main{
    public static void main(String args[]){
        int a[] = {1,2,3,4,5};
        Scanner scn = new Scanner(System.in);
        System.out.println("Enter the number to be checked: ");
        int tmp = scn.nextInt();
        for(int i=0;i < a.length;i++){
            if (a[i] == tmp){
                System.out.println("Entered Number Exist In Array At Index " + i);
                break;
            }
        }
        
    }
}

//Check and Delete an element in an array

// Check an element in an array 
import java.util.*;
class Main{
    public static void main(String args[]){
        int a[] = {1,2,3,4,5};
        int b[] = new int[a.length - 1];
        Scanner scn = new Scanner(System.in);
        System.out.println("Enter the number to be deleted : ");
        int tmp = scn.nextInt();
        for(int i=0;i < a.length;i++){
            if (a[i] != tmp){
                b[i] = a[i];
                System.out.println(a[i]+"->"+b[i]);
                
            }
        }
        
    }
}

//Write a Java program to replace an element (specific position) into an array.

//Write a Java program to replace an element (specific position) into an array.
class Main{
    public static void main(String args[]){
        int a[] = {25, 14, 56, 15, 36, 56, 77, 18, 29, 49};
        int new_index = 3;
        int new_value = 99;
        int b[] = new int[a.length];
        for(int i=0;i<b.length;i++){
            if (i == new_index){
                b[i] = new_value;
            }else{
                b[i] = a[i];
            }
        }
        for(int i=0;i<b.length;i++){
            System.out.println(b[i]);
        }
    }
}

//Sort an element in an array
class Main{
    public static void main(String args[]){
        int a[] = {4,3,1,2};
        for(int i=0; i < a.length; i++){
            for(int j= i + 1; j < a.length; j++)
                if (a[i] > a[j]){
                    int temp = a[i];
                    a[i] = a[j];
                    a[j] = temp;
            }
        }
        // Sorted array
        for(int i=0; i< a.length; i++){
            System.out.println(a[i]);
        }
    }
}


// Find secound smallest and biggest number in an array

Sorting using Array Package:

import java.util.Arrays;
class Main{
    public static void main(String args[]){
        int a[] = {10789, 2035, 1899, 1456, 2013, 
            1458, 2458, 1254, 1472, 2365, 
            1456, 2165, 1457, 245};
        Arrays.sort(a);
        for(int i=0;i < a.length; i++){
            System.out.println(a[i]);
        }
        // Print 2 smallest element
        System.out.println(a[1]);
        // Print last but one biggest number 
        System.out.println(a[a.length-2]);
}
}

-------------------------------------------------------

Java Type Casting

Type casting is when you assign a value of one primitive data type to another type.

In Java, there are two types of casting:

Widening Casting (automatically) - converting a smaller type to a larger type size
byte -> short -> char -> int -> long -> float -> double

Narrowing Casting (manually) - converting a larger type to a smaller size type
double -> float -> long -> int -> char -> short -> byte

Widening Casting:

Widening casting is done automatically when passing a smaller size type to a larger size type:

public class Main {
  public static void main(String[] args) {
    int myInt = 9;
    double myDouble = myInt; // Automatic casting: int to double

    System.out.println(myInt);      // Outputs 9
    System.out.println(myDouble);   // Outputs 9.0
  }
}

Narrowing Casting:

Narrowing casting must be done manually by placing the type in parentheses in front of the value:

public class Main {
  public static void main(String[] args) {
    double myDouble = 9.78d;
    int myInt = (int) myDouble; // Manual casting: double to int

    System.out.println(myDouble);   // Outputs 9.78
    System.out.println(myInt);      // Outputs 9
  }
}

Java Exceptions - Try...Catch:
------------------------------

When executing Java code, different errors can occur: coding errors made by the programmer, errors due to wrong input, or other unforeseeable things.

When an error occurs, Java will normally stop and generate an error message. The technical term for this is: Java will throw an exception (throw an error).

Java try and catch:

The try statement allows you to define a block of code to be tested for errors while it is being executed.

The catch statement allows you to define a block of code to be executed, if an error occurs in the try block.

The try and catch keywords come in pairs:
------------------------------------------

public class Main {
  public static void main(String[ ] args) {
    int[] myNumbers = {1, 2, 3};
    System.out.println(myNumbers[10]); // error!
  }
}


Exception in thread "main" 
java.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 3
	at Main.main(Main.java:4)


** Process exited - Return Code: 1 **

If an error occurs, we can use try...catch to catch the error and execute some code to handle it:

public class Main {
  public static void main(String[ ] args) {
    try {
      int[] myNumbers = {1, 2, 3};
      System.out.println(myNumbers[10]);
    } catch (Exception e) {
      System.out.println("Something went wrong.");
    }
  }
}

public class Main {
  public static void main(String[ ] args) {
    try {
      int[] myNumbers = {1, 2, 3};
      System.out.println(myNumbers[10]);
    } catch (Exception e) {
      System.out.println(e);
      System.out.println("Something went wrong.");
    }
  }
}

e = Holds actual error.

java.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 3
Something went wrong.


** Process exited - Return Code: 0 **

Finally:
--------

The finally statement lets you execute code, after try...catch, regardless of the result:

public class Main {
  public static void main(String[] args) {
    try {
      int[] myNumbers = {1, 2, 3};
      System.out.println(myNumbers[10]);
    } catch (Exception e) {
      System.out.println("Something went wrong.");
    } finally {
      System.out.println("The 'try catch' is finished.");
    }
  }
}

Java Exception Handling Example:
--------------------------------

public class Main{  
  public static void main(String args[]){  
   try{  
      //code that may raise exception  
      int data=100/0;  
   }catch(ArithmeticException e){
   System.out.println(e);}  
   //rest code of the program   
   System.out.println("rest of the code...");  
  }  
}  

-------------------------------------

public class Main {  
  
    public static void main(String[] args) {  
          
        int data=50/0; //may throw exception   
          
        System.out.println("rest of the code");  
          
    }  
      
}  


Exception in thread "main" 
java.lang.ArithmeticException: / by zero
	at Main.main(Main.java:5)


** Process exited - Return Code: 1 **

public class Main {  
  
    public static void main(String[] args) {  
        try  
        {  
        int data=50/0; //may throw exception   
        }  
            //handling the exception  
        catch(Exception e)  
        {  
            System.out.println(e);  
        }  
        System.out.println("rest of the code");  
    }  
      
}  

Java Multi-catch block:
-----------------------

A try block can be followed by one or more catch blocks. Each catch block must contain a different exception handler.

public class Main {  
  
    public static void main(String[] args) {  
          
           try{    
                int b[] = {1,2,3,4,5};
                System.out.println(b[10]);
                int a[]=new int[5];    
                a[5]=30/0;   
               
               }    
               catch(ArithmeticException e)  
                  {  
                   System.out.println("Arithmetic Exception occurs");  
                  }    
               catch(ArrayIndexOutOfBoundsException e)  
                  {  
                   System.out.println("ArrayIndexOutOfBounds Exception occurs");  
                  }    
               catch(Exception e)  
                  {  
                   System.out.println("Parent Exception occurs");  
                  }             
               System.out.println("rest of the code");    
    }  
}  

Java Wrapper Class:
------------------

Primitive data type: boolean, byte, char, float, int, long, short, double.

Wrapper class: Boolean, Byte, Character, Float, Integer, Long, Short, Double.

public class Main {  
    public static void main(String[] args) {  
          int a = 10; //Primitive data type.
          String name = "Sarath"; // Wrapper class.
          System.out.println(a+" "+name);
    }
}

Java has each primitive datatype has Wrapper class.

datatype starts with "Lower case".

Wrapper class starts with "Upper case".

public class Main {  
    public static void main(String[] args) {  
          int a = 10;
          Integer b = 200;
          System.out.println(a);
          System.out.println(b);
    }
}

Wrapper classes has builtin methods.

Eg: Price of prodcuts in Amazon could be in strings instead of integer.

public class Student {
    public static void main(String args[]) {
//Declaring String variable
        String mobile = "200";
        String mobilecase = "500";
//Converting String into int using Integer.parseInt()
        int price_mobile  = Integer.parseInt(mobile);
        int price_case = Integer.parseInt(mobilecase);
        int sum = price_mobile + price_case;
//Printing value of i
        System.out.println(sum);
    }
}


If your string looks like double then use Double wrapper class.

public class Student {
    public static void main(String args[]) {
//Declaring String variable
        String mobile = "200.10";
        String mobilecase = "50.75";
//Converting String into double using Double.parseDouble
        double price_mobile  = Double.parseDouble(mobile);
        double price_case = Double.parseDouble(mobilecase);
        double sum = price_mobile + price_case;
//Printing value of i
        System.out.println(sum);
    }
}


Autoboxing:
-----------

Automatic conversion of primitive datatype to wrapper class.

Eg of Autoboxing:

public class Student {
    public static void main(String args[]) {
        int a = 100;
        Integer b = a;
        System.out.println(b);
    }
}


Manual/Normal boxing.

public class Student {
    public static void main(String args[]) {
        int a = 100;
        Integer b = Integer.valueOf(a);
        System.out.println(b);
    }
}

Unboxing:
--------

Converting wrapper class object to primitive data type.

Eg: Auto unboxing

public class Student {
    public static void main(String args[]) {
        Integer b = 100;
        int a = b;
        System.out.println(a);
    }
}


Manual unboxing:

public class Student {
    public static void main(String args[]) {
        Integer b = 100;
        System.out.println(b.intValue());
    }
}
-------------------------------------------------------------






